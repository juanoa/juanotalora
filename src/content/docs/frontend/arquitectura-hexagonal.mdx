---
title: Arquitectura hexagonal
description: Cómo implementar una arquitectura limpia en un proyecto de frontend
sidebar:
  order: 1
---

import { FileTree } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';

Llevo varios años trabajando con proyectos de frontend (también algunos de backend), la mayoría de ellos en React. En todos ellos he tenido la suerte de poder de investigar nuevas formas de organizar ficheros y estructurar carpetas. Es un camino que parece nunca tener fin, siempre se te acaban ocurriendo nuevas posibles mejoras que acabas probando con los equipos y que se van iterando hasta llegar a lo que finalmente queremos.

El objetivo de post es intentar resumir todos estos conceptos que ido uniendo a lo largo de los últimos años para condensarlos y dar una guía para estructurar proyectos frontend (aunque los principios por los que se va a regir esta guía son también aplicables a cualquier otro tipo de proyecto).

## Dominio, aplicación e infraestructura

Todos tenemos en mente el típico hexágono o círculo con tres capas que representan el dominio, la aplicación y la infrasestructura. Las reglas son claras, cada capa solo puede conocer a las capas inferiores o así mismo. Es decir:

- Dominio solo puede tener importaciones de módulos de dominio
- Aplicación solo puede tener importaciones de otros módulos de aplicación y de dominio
- Infraestructura puede tener importaciones de módulos de cualquier capa

Esto nos permite tener desacoplado el core de la aplicación del resto de código. Hasta aquí la teoría que todos conocemos.

### ¿Es necesaria una arquitectura hexagonal en frontend?

WIP

## Vertical slicing y screaming architecture

WIP

Teniendo todo esto en cuenta, nuestra arquitectura de carpetas en un proyecto de frontend (en este caso usando React como biblioteca de UI) quedaría de la siguiente forma:

<FileTree>

- src
  - modules
    - products
      - domain
        - Product.ts
      - application
        - get-product.ts
      - infrastructure
        - product-rest-client.ts
      - representation
        - ProductCard.tsx
        - ProductPriceLabel.tsx
    - categories
      - domain
        - Category.ts
      - application
        - get-all-categories.ts
        - get-category.ts
      - infrastructure
        - categories-rest-client.ts
      - representation
        - CategoryGrid.tsx
        - CategoryFilters.tsx
  - pages
    - ProductPage.tsx
    - CategoryPage.tsx
- package.json

</FileTree>

Aunque está representado usando la jerarquía de un poryecto típico de React, **se puede ajustar** para llevar a cualquier otro framework o librería de UI.

<Aside>
  ¿Qué hacemos con frameworks que tienen sistemas de enrutado basados en la jerarquía de carpetas como NextJS? En ese caso siempre respetar al máximo posible el framework para asegurarnos de que vamos a escalar lo mejor posible. Sin embargo, el concepto de carpeta `modules` con el vertical slicing dentro lo podemos seguir teniendo fuera de la carpeta a partir de la cual NextJS infiere las rutas de la aplicación.
</Aside>

## Dominio

Más información en el artículo sobre Domain Driven Design.

## Aplicación

## Infrastructura

## Representación

En multitud de ocasiones se me ha ocurrido introducir la carpeta de presentación dentro de la infrastructura. Al final, se trata de código generalmente acoplado a un framework o a una librería de UI, por lo que se escapa del dominio puro de la aplicación. Siguiendo el concepto de dominio, nos gustaría ser capaces de poder desacoplar la lógica de negocio que tengamos en el frontal de la forma en la que esta se representa en la pantalla. Sin embarbo, en el caso de las aplicaciones web, la capa de representación tiene un peso demasiado importante como para no estar separada del resto.
